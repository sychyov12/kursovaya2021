\chapter{Четвертая глава. Программная реализация цифровой подписи}
\label{cha:ch_4}
\section{Арифметические операции}
\par
В описанных ранее процессах генерации и проверки подписи часто возникает необходимость производить арифметические операции с большими целыми числами. Сложность оптимальной реализации данных процессов связана с тем, что на большинстве ЭВМ хорошо отлажены арифметические операции на ограниченном наборе типов, которые, как правило, не позволяют напрямую работать с целыми числами, занимающими более 64 бит памяти.
\par
Для реализации арифметики длинных целых чисел (более 64 бит) обычно используют специальные процедуры, работающие с конструкциями замещающими целые числа. Так, большое целое число можно представить в виде массива значений целочисленного типа, каждый элемент которого отождествляется с разрядом этого числа, как если бы оно было записанно в системе счисления с некоторым основанием. Оптимальная реализация процессов умножения или деления таких структур сама по себе является сложной задачей.
\par
Распространенность данной проблемы способствовала созданию готовых библиотек для реализации длинной арифметики в разных языках программирования. В языке C\# длинная арифметика представлена классом <<BigInteger>>. Данный класс позволяет работать с большими целыми числами, используя стандартные операторы (<<+>>, <<->>, <<*>>, <</>> и <<\%>>).
\par
Стоит отметить одну особенность данного типа, связанную с процессом формирования и проверки ЭЦП. Дело в том, что класс <<BigInteger>> содержит методы преобразования чисел в массив байт и обратно. Данные методы можно использовать для реализации процессов эквивалентных тем, что описаны в формулах (\ref{eq:bv1}), (\ref{eq:bv2}). Основным отличием является то, что в стандарте описан порядок бит от старшего к младшему, в то время как класс <<BigInteger>> предполагает порядок от младшего к старшему. В данной работе будем использовать порядок бит от младшего к старшему, для избежания лишних инверсий массивов при преобразованиях. Однако, при интеграции с внешними системами, необходимо учесть возможные инверсии. 
\section{Действия в группе точек эллиптической кривой}
\par
По аналогии с реализацией функции хэширования, выделим все свойства и методы касающиеся реализации процессов цифровой подписи в отдельный класс "--- <<GR3410\_2012\_Main>>. В качестве свойств класса определим параметры схемы цифровой подписи (пункт 4.3) и, дополнительно, добавим переменную, отражающую длину хэша "--- <<L>> (Листинг 5.1).
\lstinputlisting[caption={Параметры схемы цифровой подписи}]{inc/src/5/l51.cs}
\par
Далее определим методы, необходимые для расчета сравнений по модулю. Определим метод, вычисляющий вычет по модулю, метод, вычисляющий обратный элемент по модулю и метод, вычисляющий деление по модулю. Во втором методе, для расчета обратного элемента, используем расширенный алгоритм Евклида. Код методов представлен в Листинге 5.2.
\lstinputlisting[caption={Методы для расчета сравнений по модулю}]{inc/src/5/l52.cs}
\par
Каждую точку эллиптической кривой $Q(x,y)$ будем хранить в 2-х целочисленных переменных, отождествляемых с $x$-координатой и $y$-координатой точки. Метод, осуществляющий сложение в группе точек эллиптической кривой, определим как процедуру, принимающую координаты слагаемых точек и записывающую результат сложения в координаты третьей точки. В качестве нулевой точки $O$ возьмем точку с координатами $(-1,\;-1)$. Код метода, осуществляющего сложение в группе точек эллиптической кривой, представлен в Листинге 5.3.
\lstinputlisting[caption={Метод, осуществляющий сложение в группе точек}]{inc/src/5/l53.cs}
\par
Для получения кратных точек (\ref{eq:kP}) необходимо реализовать скалярное умножение точки эллиптической кривой на положительное целое число. Умножение должно эффективно работать с большими числами. В связи с этим, необходимо реализовать механизм быстрого умножения на скаляр по следующей формуле
\begin{equation}
kP = k_0 P + k_1 P^2 + \dots + k_n P^{2^n},\;k = \sum_{i=0}^{i=n}k_i2^i,\;k_i\in\{0,\;1\}\; i=0,\dots,n,
\end{equation} 
где $P\in E$(\ref{eq:E})$,\; k \in \mathbb{N}$.
\par
Код метода, осуществляющего умножение на скаляр в группе точек эллиптической кривой, представлен в Листинге 5.4.
\lstinputlisting[caption={Метод, осуществляющий умножение на скаляр}]{inc/src/5/l54.cs}
\section{Процесс формирования подписи}
В процессе формирования подписи необходимо генерировать случайные (псевдослучайные) числа (Шаг 3 алгоритма I). Для генерации псевдослучайных значений в рассматриваемом языке служит класс <<Random>>, экземпляры которого нужно инициализировать некоторым значением (например, текущим системным временем). Определить подобный объект в классе цифровой подписи можно следующим образом (Листинг 5.5).
\lstinputlisting[caption={Объявление генератора случайных чисел}]{inc/src/5/l55.cs}
\par
Для генерации больших случайных чисел будем использовать специальный метод, принимающий в качестве аргумента целое положительное число $p$ и возвращающий случайное число в диапазоне от $0$ до $p$ (Листинг 5.6).
\newpage
\lstinputlisting[caption={Метод для генерации случайных чисел}]{inc/src/5/l56.cs}
\par
Завершающий этап процесса генерации подписи предполагает преобразование чисел в двоичные векторы и их последующую конкатенацию (Шаг 6 алгоритма I). Данный процесс выделим в отдельный метод, учитывая специфику реализации (Листинг 5.7).
\lstinputlisting[caption={Преобразование чисел в двоичные векторы и их конкатенация}]{inc/src/5/l57.cs}
\par
Процесс формирования цифровой подписи будем осуществлять в помощью метода, принимающего в качестве аргументов хэш подписываемого сообщения и ключ подписи и возвращающего цифровую подпись. Входные и выходные значения запишем в формате массива байт. Для преобразования массива байт в числа определим специальный метод (Листинг 5.8).
\lstinputlisting[caption={Преобразование массива байт в соответствующее ему целое число}]{inc/src/5/l58.cs}
\par
Метод, осуществляющий процесс формирования подписи, представлен в Листинге 5.9. Порядок вычислений в описанном в Листинге 5.9 методе аналогичен алгоритму I.
\lstinputlisting[caption={Метод, осуществляющий процесс формирования подписи}]{inc/src/5/l59.cs}
\par
\section{Процесс проверки подписи}
В начале процесса проверки цифровой подписи необходимо получить по имеющийся подписи $\zeta$ числа $r$ и $s$ (Шаг 1 алгоритма II). Для этого, определим специальный метод, для получения чисел $r$ и $s$ по известной подписи $\zeta$ (Листинг 5.10).
\lstinputlisting[caption={Получение значений r и s из цифровой подписи}]{inc/src/5/l510.cs}
\par
Аналогично процессу формирования подписи, процесс проверки цифровой подписи оформим в виде отдельного метода, принимающего хэш подписанного сообщения, цифровую подпись и координаты ключа проверки подписи $x_q$, $y_q$. Выходным значением метода, отвечающего за проверку подписи, положим логическое значение, являющееся свидетельством достоверности подписи. Код метода проверки подписи представлен в Листинге 5.11. Порядок вычислений в описанном в Листинге 5.11 методе аналогичен алгоритму II.
\lstinputlisting[caption={Метод, осуществляющий проверку подписи}]{inc/src/5/l511.cs}
\section{Хранение параметров и значений}
В описанных ранее методах класса все глобальные методы (доступные при работе с классом вне его кода) определены относительно входных и выходных переменных, заданных массивами байт. Данный подход позволяет легко хранить данные параметры в памяти компьютера. Однако стоит заметить, что однотипность всех этих переменных может способствовать возникновению ошибок, связанных с неверным определением назначения той или иной переменной. Со структурной точки зрения более верным подходом являлось бы определение более точных типов для различных параметров алгоритма. Такой подход, в конечном итоге, упростит работу с переменными.
\par
Язык программирования C\# определяет механизмы сериализации классов в файлы формата XML, позволяющие хранить в файле не только переменные класса но и его структуру. Такой подход позволяет точно идентифицировать XML-файл как сериализованную версию экземпляра класса, что позволяет избежать подмены типов.
\par
Таким образом, определим ряд классов, отождествленных с различными параметрами процессов формирования и проверки подписи. Выделим следующие группы параметров:
\begin{itemize}
	\item параметры схемы цифровой подписи;
	\item ключ подписи;
	\item ключ проверки подписи;
	\item цифровая подпись.
\end{itemize}
\par
Каждой из выделенных групп поставим в соответствие сериализуемый класс. Список классов представлен в Листинге 5.12.
\newpage
\lstinputlisting[caption={Список классов, представляющих параметры алгоритмов}]{inc/src/5/l512.cs}
\par
Полученные классы для параметров можно использовать в классе <<GR3410\_2012\_Main>> при инициализации и при расчете процессов формирования и проверки подписи. Таким образом, определим 2 варианта конструктора класса: с использованием класса параметров схемы и без (Листинг 5.13).
\lstinputlisting[caption={2 варианта конструктора класса <<GR3410\_2012\_Main>> }]{inc/src/5/l513.cs}
\par
Вариант расчета процедур формирования и проверки подписи с использованием выделенных классов параметров представлен в Листинге 5.14.
\lstinputlisting[caption={Расчет процедур формирования и проверки подписи с использованием выделенных классов параметров}]{inc/src/5/l514.cs}
\par
Таким образом, определены все необходимые компоненты для реализации процессов проверки и генерации цифровой подписи согласно ГОСТ Р 34.10-2012. Полный код класса <<GR3410\_2012\_Main>> представлен в приложении В. В качестве практического применения разработанного класса в рамках данной работы был написан ряд вспомогательных программ, осуществляющих редактирование параметров, генерацию подписи и проверку подписи. Пример работы с данными программами представлен в приложении Г.
