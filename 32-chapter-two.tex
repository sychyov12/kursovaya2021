\chapter{Вторая глава. Программная реализация хэш-функции}
\label{cha:ch_2}
\section{Общая схема алгоритма}
\par
В данном разделе рассматриваются типичные алгоритмические приемы используемые в различных реализациях хэш-функции. Затрагиваются вопросы механизма хранения констант и перечня используемых конструкций. Весь исходный код написан на языке программирования C\#. По возможности минимизировано использование специфичных языковых конструкций, благодаря чему код может быть легко перенесен на любой С-подобный язык программирования.
\par
Для начала определим используемые в алгоритме типы данных. Все описания функций и переменных, используемых при расчете хэша, целесообразно выделить в отдельный класс. Присвоим ему идентификатор <<GR3411\_2012\_Hash>>, который и будем использовать. Использование выделенного класса упрощает работу с параметрами и позволяет удобно организовать дополнительные разовые расчеты, речь о которых пойдет в следующем пункте. Все дальнейшие описанные в данной главе методы и свойства предполагаются членами данного класса.
\par
Простейшая сигнатура метода расчета значения хэша предполагает использование массива байт в качестве входного значения и массива байт в качестве возвращаемого значения. В случае, если необходимо вычислить хэш-значение от файла, более оптимален подход последовательного чтения файла по блокам в процессе вычисления хэша, а не чтение файла целиком в массив. Для этих целей в разных средах разработки служат специфичные объекты, имеющие похожий функционал. В рассматриваемом случае, для данных целей будет служить класс <<Stream>>, который и будем передавать в качестве аргумента метода.
Таким образом, определим два метода для расчета хэша.
\par ГОСТ Р 34.11-2012 определяет 2 варианта хэш-функции с длиной выходного значения 256 и 512 бит. Алгоритм расчета значения в обоих вариантах схож, и для краткости изложения выделим параметр длины возвращаемого значения в качестве свойства нашего класса. В итоге, приходим к следующему шаблону (Листинг 3.1).

\renewcommand{\lstlistingname}{Листинг}

\lstinputlisting[caption={Схема класса GR3411\_2012\_Hash}]{inc/src/l31.cs}

\par
Далее определим код исполняющий основную схему алгоритма хэширования. Пока представим, что у нас уже определена функция сжатия и она имеет следующую сигнатуру (Листинг 3.2).
\lstinputlisting[caption={Сигнатура функции сжатия}]{inc/src/l32.cs}
\par
Реализуем основную схему алгоритма. Также будем группировать операции по трем этапам. Для начала ограничимся случаем вычисления хэша от массива байт. Промежуточные блоки будем хранить в виде массива байт размера 64. Сложение по модулю 512 будем осуществлять с помощью специального метода (Листинг 3.3).
\lstinputlisting[caption={Метод, осуществляющий сложение по модулю $2^{512}$}]{inc/src/l33.cs}
\par
Итерационным переменным на первом этапе присвоим нулевые значения, за исключением вектора $IV$ в случае длины выходного значения равной 256 битам. Далее будем последовательно копировать из основного массива во вспомогательный блоки согласно шагу алгоритма 2.1 и производить вычисления 2.2-2.7, если это возможно. Для контроля длины оставшейся части введем специальную переменную, значение которой будем уменьшать по мере обработки массива. Далее следует третий этап алгоритма и возврат значения. Код метода представлен в Листинге 3.4.
\lstinputlisting[caption={Метод, вычисляющий хэш-сумму от массива байт}]{inc/src/l34.cs}
\par
Что касается поточного расчета хэш-суммы, то общую схему можно оставить прежней за исключением, непосредственно, чтения из потока и начальной обработки полученных данных. Код поточной реализации представлен в Листинге 3.5.
\lstinputlisting[caption={Метод, вычисляющий хэш-сумму потоковых данных}]{inc/src/l35.cs}

\section{Определение констант}
\par
Параметры алгоритма включают подстановку бит (\ref{sa}), перестановку байт (\ref{pa}), матрицу $A$ (\ref{aa}) и итерационные константы (\ref{ca}). Удобно определять необходимые константы в программном коде, оттуда они будут считанны компилятором. Иной вариант предполагает размещение параметров в отдельном файле, откуда их будет необходимо считать перед вычислением значения. Для простоты изложения выберем первый вариант. Начнем с подстановки байт. Запишем ее в виде массива байт, в котором индекс элемента выполняет роль входного значения, а элемент является выходным значением (Листинг 3.6). 
\lstinputlisting[caption={Массив подстановки байт}]{inc/src/l36.cs}
\par
Перестановку байт также можно бы было записать в виде массива байт. Однако, перестановка $\tau$ (\ref{pa}) имеет специфический вид аналогичный транспонированию матрицы $8\times 8$. Это позволяет использовать смещение индекса вместо обращения к массиву. Поэтому массив перестановки байт редко встречается в реализациях. Пока отложим этот момент до следующего пукта, и опустим объявление массива перестановки.
\par
Матрица $A$ имеет размеры $64\times 64$. Операция умножения на матрицу $A$ в $L$-преобразовании сопряжена с побитовым сложением различных строк матрицы, согласно формуле (\ref{eq:lxor}). Этот процесс эффективно реализуется путем сложения 64-битных целых чисел, которые удобно представлять в памяти компьютера. В используемом языке данный тип имеет идентификатор <<ulong>>. Таким образом, запишем матрицу $A$ как массив из целых 64-битных чисел, представляющих ее строки (Листинг 3.7).
\lstinputlisting[caption={Массив строк матрицы $A$}]{inc/src/l37.cs}
\par
Для хранения итерационных констант в памяти, можно выделить 2 основных подхода, различающиеся типом используемого массива. Все зависит от того, какой тип применяется для хранения промежуточных значений при расчете функции сжатия. Алгоритм работает с блоками длиной 512 бит, что соответствует массиву байт длиной 64 или массиву 64-битных целых чисел длиной 8. Второй подход, как правило, приводит к некоторому ускорению расчетов за счет применения операций к более емкому типу. В данной работе будем использовать второй вариант. Все 12 констант определим в двумерном массиве 64-битных целых чисел (Листинг 3.8).
\lstinputlisting[caption={Значения итерационных констант}]{inc/src/l38.cs}
\section{Функция сжатия}
\par
Как уже ранее было отмечено, постараемся реализовать функцию сжатия так, чтобы основная часть операций производилась над 64-битными целыми числами. Еще стоит отметить, что выделение новой памяти в программной куче, как правило, является трудоемкой операцией и по возможности его необходимо избежать в функции сжатия. Для этого результаты всех расчетов необходимо записывать в предварительно выделенные области памяти. Для этого, все необходимые переменные можно было бы передать в функцию сжатия в качестве аргументов. Но это придаст сигнатуре громоздкость, которой можно избежать, определив все необходимые переменные во внешней области. В нашем случае их можно определить непосредственно внутри класса. Приведем их список в Листинге 3.9.
\lstinputlisting[caption={Вспомогательные переменные}]{inc/src/l39.cs}
\par
Из сигнатуры функции сжатия, которой мы пользовались ранее, видно, что входные и выходные значения представляют собой массивы байт. Для того, чтобы производить основные операции над 64-битными целыми числами, необходимо иметь возможность переводить массив байт в соответствующий ему массив 64-битных целых чисел и наоборот. Для этих целей выделим 2 специальных метода (Листинг 3.10).
\lstinputlisting[caption={Методы для преобразования типов}]{inc/src/l310.cs}
\par
В ходе вычисления функции сжатия используется побитовое сложение двоичных векторов. Определим данную операцию для массива из 8-ми 64-битных целых чисел. Будем передавать в метод адрес слагаемых и результата. Вместо перебора индексов в цикле эффективней, с точки зрения времени выполнения, указать все индексы вручную. Код метода представлен в Листинге 3.11.
\lstinputlisting[caption={Метод для побитового сложения}]{inc/src/l311.cs}
Преобразование $LPSX$ оформим одним методом, принимающим слагаемые $X$ и записывающим результат в третью переменную. Но сначала необходимо определиться с его оптимизацией, заключающейся в использовании массива предпросчета для расчета $LS$ преобразования.
Поясним данный момент. Вначале запишем реализацию без использования предпросчета (Листинг 3.12).
\lstinputlisting[caption={Неоптимизированный вариант $LPSX$-преобразования}]{inc/src/l312.cs}
\par В данном варианте уже используется смещение индекса для реализации $P$ - преобразования. Подробнее об этом приеме написано, например, в \cite{LebedevHash}.
\par Разберем Листинг 3.12 подробнее. Вначале вычисляется $X$-преобразование, и его результат записывается во вспомогательный массив. Далее, в цикле происходит перебор индексов предполагаемого вывода. Затем, внутри этого цикла происходит выборка байт со смещением индекса и учетом $S$-преобразования и побитовое сложение строк матрицы по битам каждого байта, результат которого и записывается в результирующий массив по текущему индексу.
\par Суть оптимизации заключается в том, что для каждого байта по битам которого складываются строки матрицы $A$, зная его смещение вдоль 64-битного блока, можно заранее посчитать сумму строк.  В дополнение к этому, к каждому из возможных байт можно применить $S$-преобразование, для того, чтобы сократить дальнейшие расчеты. Так, для хранения всех таких сумм понадобится $8\times 256$ 64-битных целых чисел. Все такие значения вычислим однократно и запишем в двумерный массив <<LSPrecalc>> с помощью специального метода (Листинг 3.13).
\lstinputlisting[caption={Метод предпросчета}]{inc/src/l313.cs}
\par
Метод, описанный в Листинге 3.13, можно вызвать как в конструкторе, так и непосредственно перед вычислением хэша. Ввиду небольшого размера таблицы предпросчета иногда ее целиком размещают в коде программы, опуская определения $S$ и $A$. Например, такой подход используется в реализации \cite{degtyarevHash}. Вариант расчета LPSX с использованием предпросчета показан в Листинге 3.14.
\lstinputlisting[caption={Оптимизированный вариант $LPSX$-преобразования}]{inc/src/l314.cs}
\par
Далее остается реализовать преобразование $E$(\ref{E}), подстановку значений $K_i$(\ref{Ki}) и непосредственно расчет функции сжатия $g_N$(\ref{gn}) c поправкой на преобразования типов. 
Перечисленные методы показаны в Листинге 3.15.
\lstinputlisting[caption={Расчет функции $g_N$}]{inc/src/l315.cs}
\par
В итоге определены все необходимые методы и переменные для расчета хэш-функции по ГОСТ Р 34.11-2012. Полная версия класса с реализацией представлена в приложении А. Примеры расчета различных значений хэша представлены в приложении Б.